const express = require('express');
const router = express.Router();

//these endpoints use structured validation from
const {registerValidation, loginValidation} = require('../validation');//validation.js/hapijoi

const bcrypt = require('bcryptjs'); //for password hashing

const jwt = require('jsonwebtoken'); //after logging in you get a token to do protected routes
const verify = require('./verifyToken'); //add to routes for token verification


//these endpoints come from
//app.use('/api/user', require('./Routes/auth')); within app.js
//these endpoints use User.js as a model
const todoUser = require('../models/TodoUser');

//register a user
router.post('/register', async (req, res) => {

    //we can destruct the response error message generated by the hapijoi methods we created in
    //validation.js
    //notice that you send the joi registerValidation function our req.body as a param

    const {error} = registerValidation(req.body);
    if (error) {
        //here we grab a specific item from the error object generated by hapi/joi
        //you should return return json here bc its easier to work with
        return res.status(400).send(res.send({error: error.details[0].message}));
    }

    //checking if email already exists and sending back a message
    const emailExists = await todoUser.findOne({email: req.body.email});
    if (emailExists) {
        return res.status(400).send({error: 'Email already exists'});
    }

    //Hash passwords
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(req.body.password, salt);

    //creating a new user and saving it into our database
    //i don't think the to/do field is needed during registering bc a new user shouldn't have any to/dos, but i will keep it here for testing
    const user = new todoUser({
        email: req.body.email,
        password: hashedPassword,
        todos: req.body.todos
    });
    try {
        const savedUser = await user.save();
        res.send({user: user._id});
    } catch (e) {
        res.status(400).send(e);
    }
});


//login with an email and password
//this doesn't reference to/dos i think thats ok because you only need to GET the to/dos we can call this get method when when the To/doList component mounts and make a get request based on the props the component gets when after a user logs in
router.post('/login', async (req, res) => {

    const {error} = loginValidation(req.body);
    if (error) {
        return res.status(400).send(res.send({error: error.details[0].message}));
    }

    const user = await todoUser.findOne({email: req.body.email});
    if (!user) {
        return res.status(400).send({error: 'Email does not exist'});
    }

    //check if pass is correct
    const validPass = await bcrypt.compare(req.body.password, user.password);

    if (!validPass) {
        return res.status(400).send({error: 'Invalid Password'});
    }

    //create and assign token
    try {
        const token = jwt.sign({_id: user._id}, process.env.TOKEN_SECRET);
        res.header('auth-token', token).send({token, id: user._id}).status(200);

    } catch (e) {
        console.log(e)
    }

});

//use the model to find the user's list of todos send them back to the client then render them
//get a users todos, need to fetch user by id

//get a single users todos
//(how can this be a get request if i need information from the request)
router.post('/getUserById', async (req, res) => {
    try {
        const singleUser = await todoUser.findById(req.body.id);
        return res.json(singleUser);
    } catch (err) {
        return res.json({message: err});
    }
});


//ADD A NEW TO/DO
//set will REPLACE the item, meaning any newly added item simply replaces the old one
router.post('/addToUsersTodos', async (req, res) => {

    //console.log('req.body.id', req.body.id); //user id
    //console.log('req.body.update.todo.id', req.body.update.todo.id); //singular to/do id

    try {
        const response = await todoUser.findByIdAndUpdate(
            req.body.id,
            {$push: {todos: req.body.update.todo}}
        );

        return res.json(response);
    } catch (err) {
        return res.json({message: err});
    }
});

//https://stackoverflow.com/questions/15691224/mongoose-update-values-in-array-of-objects
router.post('/updateUsersTodos', async (req, res) => {

    todoUser.updateOne(
        {'todos.id': req.body.todo.id},
        {'$set': {'todos.$.text': req.body.todo.text}},
        function (err) {

            if (err) {
                return res.status(400).send({error: 'Update Failed'});
            }
            return res.status(200).send({success: 'Update Sent'});
        })
});


//destructuring the body of an axios delete requests works but when you use req.body.id it doesn't work
router.delete('/deleteUsersTodos', async (req, res) => {

    const {todo} = req.body;
    console.log(todo);
    try {
        let response = await todoUser.findByIdAndUpdate(
            req.body.id,
            {$pull: {todos: todo}}
        );
        return res.json(response);
    }
    catch (err) {
        return res.json({message: err});
    }
});

module.exports = router;

